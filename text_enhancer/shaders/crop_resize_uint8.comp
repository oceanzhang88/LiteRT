#version 450
#extension GL_EXT_shader_8bit_storage : require // <-- CHANGED: 1. Enable 8-bit storage

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input: Storage Image
layout (binding = 0, rgba8) uniform readonly image2D u_InputTexture;

// Output: Storage Buffer
layout(std430, set = 0, binding = 1) buffer OutputBuffer {
    uint8_t data[]; // <-- CHANGED: 2. Use 8-bit unsigned integer
} out_buffer;

// Push constants
layout(push_constant) uniform PushConstants {
    ivec2 in_dims;
    ivec2 crop_dims;
    ivec2 out_dims;
} pc;

// Bilinear sampling (Identical to float version)
vec4 textureBilinear(vec2 uv) {
    vec2 texel_pos = uv * vec2(pc.in_dims) - 0.5;
    vec2 floor_pos = floor(texel_pos);
    vec2 fract_pos = texel_pos - floor_pos;
    ivec2 p00 = ivec2(floor_pos);
    ivec2 p10 = p00 + ivec2(1, 0);
    ivec2 p01 = p00 + ivec2(0, 1);
    ivec2 p11 = p00 + ivec2(1, 1);
    p00 = clamp(p00, ivec2(0), pc.in_dims - 1);
    p10 = clamp(p10, ivec2(0), pc.in_dims - 1);
    p01 = clamp(p01, ivec2(0), pc.in_dims - 1);
    p11 = clamp(p11, ivec2(0), pc.in_dims - 1);
    vec4 v00 = imageLoad(u_InputTexture, p00);
    vec4 v10 = imageLoad(u_InputTexture, p10);
    vec4 v01 = imageLoad(u_InputTexture, p01);
    vec4 v11 = imageLoad(u_InputTexture, p11);
    vec4 interp_x0 = mix(v00, v10, fract_pos.x);
    vec4 interp_x1 = mix(v01, v11, fract_pos.x); 
    return mix(interp_x0, interp_x1, fract_pos.y);
}


void main() {
    ivec2 out_coord = ivec2(gl_GlobalInvocationID.xy);
    if (out_coord.x >= pc.out_dims.x || out_coord.y >= pc.out_dims.y) {
        return;
    }

    // --- CROP & RESIZE LOGIC ---
    ivec2 crop_offset = (pc.in_dims - pc.crop_dims) / 2;
    vec2 scale = vec2(pc.crop_dims - 1) / vec2(pc.out_dims - 1);
    vec2 crop_coord = vec2(out_coord) * scale;
    vec2 in_coord = crop_coord + vec2(crop_offset);
    vec2 uv = in_coord / vec2(pc.in_dims);
    
    // --- SAMPLING ---
    vec4 color = textureBilinear(uv); // color is [0.0, 1.0]

    // --- WRITE TO BUFFER ---
    
    // 1. Convert [0.0, 1.0] float to [0, 255] integer
    int r = int(clamp(color.r * 255.0, 0.0, 255.0));
    int g = int(clamp(color.g * 255.0, 0.0, 255.0));
    int b = int(clamp(color.b * 255.0, 0.0, 255.0));

    // 2. Calculate the 1D pixel index
    uint pixel_index = uint(out_coord.y * pc.out_dims.x + out_coord.x);
    
    // 3. Calculate the base *byte* index
    uint out_base_index = pixel_index * 3;

    // 4. Write the 3 uint8_t values
    out_buffer.data[out_base_index + 0] = uint8_t(r); // <-- CHANGED: 3. Cast to uint8_t
    out_buffer.data[out_base_index + 1] = uint8_t(g); // <-- CHANGED: 4. Cast to uint8_t
    out_buffer.data[out_base_index + 2] = uint8_t(b); // <-- CHANGED: 5. Cast to uint8_t
}